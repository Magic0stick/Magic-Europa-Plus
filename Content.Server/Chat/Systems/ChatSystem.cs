// SPDX-FileCopyrightText: 2022 EmoGarbage404 <98561806+EmoGarbage404@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Flipp Syder <76629141+vulppine@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Julian Giebel <juliangiebel@live.de>
// SPDX-FileCopyrightText: 2022 Justin Trotter <trotter.justin@gmail.com>
// SPDX-FileCopyrightText: 2022 Júlio César Ueti <52474532+Mirino97@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Kevin Zheng <kevinz5000@gmail.com>
// SPDX-FileCopyrightText: 2022 Morber <14136326+Morb0@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Rane <60792108+Elijahrane@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Taran <legendaryflame50@gmail.com>
// SPDX-FileCopyrightText: 2022 Tom Richardson <tgrkzus@gmail.com>
// SPDX-FileCopyrightText: 2022 Tomás Alves <tomasalves35@gmail.com>
// SPDX-FileCopyrightText: 2022 Veritius <veritiusgaming@gmail.com>
// SPDX-FileCopyrightText: 2022 keronshb <54602815+keronshb@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 mirrorcult <lunarautomaton6@gmail.com>
// SPDX-FileCopyrightText: 2022 wrexbe <81056464+wrexbe@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 20kdc <asdd2808@gmail.com>
// SPDX-FileCopyrightText: 2023 AJCM-git <60196617+AJCM-git@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Alex Evgrashin <aevgrashin@yandex.ru>
// SPDX-FileCopyrightText: 2023 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 DrSmugleaf <drsmugleaf@gmail.com>
// SPDX-FileCopyrightText: 2023 Errant <35878406+dmnct@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Hannah Giovanna Dawson <karakkaraz@gmail.com>
// SPDX-FileCopyrightText: 2023 HerCoyote23 <131214189+HerCoyote23@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Interrobang01 <113810873+Interrobang01@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Jezithyr <jezithyr@gmail.com>
// SPDX-FileCopyrightText: 2023 Kara <lunarautomaton6@gmail.com>
// SPDX-FileCopyrightText: 2023 Mr. 27 <45323883+27alaing@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Pieter-Jan Briers <pieterjan.briers@gmail.com>
// SPDX-FileCopyrightText: 2023 Skye <57879983+Rainbeon@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 TemporalOroboros <TemporalOroboros@gmail.com>
// SPDX-FileCopyrightText: 2023 Visne <39844191+Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 0x6273 <0x40@keemail.me>
// SPDX-FileCopyrightText: 2024 AJCM <AJCM@tutanota.com>
// SPDX-FileCopyrightText: 2024 Aiden <aiden@djkraz.com>
// SPDX-FileCopyrightText: 2024 Alex Pavlenko <diraven@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Alice "Arimah" Heurlin <30327355+arimah@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Boaz1111 <149967078+Boaz1111@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Chief-Engineer <119664036+Chief-Engineer@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Cojoke <83733158+Cojoke-dot@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 DrSmugleaf <10968691+DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ed <96445749+TheShuEd@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Emisse <99158783+Emisse@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Errant <35878406+Errant-4@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Flareguy <78941145+Flareguy@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ghagliiarghii <68826635+Ghagliiarghii@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 HS <81934438+HolySSSS@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 IProduceWidgets <107586145+IProduceWidgets@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Leon Friedrich <60421075+ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 LordCarve <27449516+LordCarve@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Mervill <mervills.email@gmail.com>
// SPDX-FileCopyrightText: 2024 MilenVolf <63782763+MilenVolf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Mr. 27 <45323883+Dutch-VanDerLinde@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Nemanja <98561806+EmoGarbage404@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 PJBot <pieterjan.briers+bot@gmail.com>
// SPDX-FileCopyrightText: 2024 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 2024 Plykiya <58439124+Plykiya@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Redfire1331 <125223432+Redfire1331@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Rouge2t7 <81053047+Sarahon@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 ShadowCommander <10494922+ShadowCommander@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 SlamBamActionman <83650252+SlamBamActionman@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Southbridge <7013162+southbridge-fur@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Spanky <scott@wearejacob.com>
// SPDX-FileCopyrightText: 2024 Spessmann <156740760+Spessmann@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Tayrtahn <tayrtahn@gmail.com>
// SPDX-FileCopyrightText: 2024 Thomas <87614336+Aeshus@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Truoizys <153248924+Truoizys@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 TsjipTsjip <19798667+TsjipTsjip@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ubaser <134914314+UbaserB@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Vasilis <vasilis@pikachu.systems>
// SPDX-FileCopyrightText: 2024 beck-thompson <107373427+beck-thompson@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 chavonadelal <156101927+chavonadelal@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deltanedas <39013340+deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 2024 ike709 <ike709@github.com>
// SPDX-FileCopyrightText: 2024 ike709 <ike709@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 lzk <124214523+lzk228@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 metalgearsloth <31366439+metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 2024 neutrino <67447925+neutrino-laser@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 osjarw <62134478+osjarw@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 plykiya <plykiya@protonmail.com>
// SPDX-FileCopyrightText: 2024 redfire1331 <Redfire1331@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 slarticodefast <161409025+slarticodefast@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Арт <123451459+JustArt1m@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aiden <28298836+Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aidenkrz <aiden@djkraz.com>
// SPDX-FileCopyrightText: 2025 Aviu00 <93730715+Aviu00@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 BombasterDS <deniskaporoshok@gmail.com>
// SPDX-FileCopyrightText: 2025 BombasterDS2 <shvalovdenis.workmail@gmail.com>
// SPDX-FileCopyrightText: 2025 CerberusWolfie <wb.johnb.willis@gmail.com>
// SPDX-FileCopyrightText: 2025 FoxxoTrystan <45297731+FoxxoTrystan@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 GoobBot <uristmchands@proton.me>
// SPDX-FileCopyrightText: 2025 Ilya246 <57039557+Ilya246@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 IrisTheAmped <iristheamped@gmail.com>
// SPDX-FileCopyrightText: 2025 John Willis <143434770+CerberusWolfie@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Mnemotechnican <69920617+Mnemotechnician@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Piras314 <p1r4s@proton.me>
// SPDX-FileCopyrightText: 2025 Rinary <72972221+Rinary1@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 SX_7 <sn1.test.preria.2002@gmail.com>
// SPDX-FileCopyrightText: 2025 Skubman <ba.fallaria@gmail.com>
// SPDX-FileCopyrightText: 2025 Superlagg <sprambersonson@gmail.com>
// SPDX-FileCopyrightText: 2025 Tim <timfalken@hotmail.com>
// SPDX-FileCopyrightText: 2025 Timfa <timfalken@hotmail.com>
// SPDX-FileCopyrightText: 2025 VMSolidus <evilexecutive@gmail.com>
// SPDX-FileCopyrightText: 2025 Winkarst <74284083+Winkarst-cpu@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 ash lea <ashkitten@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 gluesniffler <159397573+gluesniffler@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 pathetic meowmeow <uhhadd@gmail.com>
//
// SPDX-License-Identifier: AGPL-3.0-or-later

using Content.Goobstation.Shared.Loudspeaker.Events; // goob - loudspeakers
using System.Collections.Immutable; // Goobstation - Starlight collective mind port
using System.Globalization;
using System.Linq;
using System.Text;
using Content.Server._Goobstation.Wizard.Systems;
using Content.Server.Administration.Logs;
using Content.Server.Administration.Managers;
using Content.Server.Chat.Managers;
using Content.Server.GameTicking;
using Content.Server._EinsteinEngines.Language; // Einstein Engines - Language
using Content.Server.Speech.Prototypes;
using Content.Server.Speech.EntitySystems;
using Content.Server.Station.Components;
using Content.Server.Station.Systems;
using Content.Shared._Goobstation.Wizard.Chuuni;
using Content.Shared.ActionBlocker;
using Content.Shared.Administration;
using Content.Shared.CCVar;
using Content.Shared.Chat;
using Content.Shared._Starlight.CollectiveMind; // Goobstation - Starlight collective mind port
using Content.Shared.Database;
using Content.Shared.Examine;
using Content.Shared.Ghost;
using Content.Shared._EinsteinEngines.Language; // Einstein Engines - Language
using Content.Shared.IdentityManagement;
using Content.Shared.Mobs.Systems;
using Content.Shared.Players;
using Content.Shared.Players.RateLimiting;
using Content.Shared.Radio;
using Content.Shared.Whitelist;
using Content.Goobstation.Common.Chat;
using Content.Goobstation.Common.Traits;
using Content.Server._Europa.TTS;
using Content.Server.Radio;
using Content.Shared._EinsteinEngines.Language.Systems;
using Content.Shared._Europa;
using Robust.Server.Player;
using Robust.Shared.Audio;
using Robust.Shared.Audio.Systems;
using Robust.Shared.Configuration;
using Robust.Shared.Console;
using Robust.Shared.Network;
using Robust.Shared.Player;
using Robust.Shared.Prototypes;
using Robust.Shared.Random;
using Robust.Shared.Replays;
using Robust.Shared.Utility;

namespace Content.Server.Chat.Systems;

// TODO refactor whatever active warzone this class and chatmanager have become
/// <summary>
///     ChatSystem is responsible for in-simulation chat handling, such as whispering, speaking, emoting, etc.
///     ChatSystem depends on ChatManager to actually send the messages.
/// </summary>
public sealed partial class ChatSystem : SharedChatSystem
{
    [Dependency] private readonly IReplayRecordingManager _replay = default!;
    [Dependency] private readonly IConfigurationManager _configurationManager = default!;
    [Dependency] private readonly IChatManager _chatManager = default!;
    [Dependency] private readonly IChatSanitizationManager _sanitizer = default!;
    [Dependency] private readonly IAdminManager _adminManager = default!;
    [Dependency] private readonly IPlayerManager _playerManager = default!;
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
    [Dependency] private readonly IRobustRandom _random = default!;
    [Dependency] private readonly IAdminLogManager _adminLogger = default!;
    [Dependency] private readonly ActionBlockerSystem _actionBlocker = default!;
    [Dependency] private readonly StationSystem _stationSystem = default!;
    [Dependency] private readonly MobStateSystem _mobStateSystem = default!;
    [Dependency] private readonly SharedAudioSystem _audio = default!;
    [Dependency] private readonly ReplacementAccentSystem _wordreplacement = default!;
    [Dependency] private readonly EntityWhitelistSystem _whitelistSystem = default!;
    [Dependency] private readonly ExamineSystemShared _examineSystem = default!;
    [Dependency] private readonly TelepathicChatSystem _telepath = default!; // Goobstation Change
    [Dependency] private readonly GhostVisibilitySystem _ghostVisibility = default!; // Goobstation Change
    [Dependency] private readonly ScryingOrbSystem _scrying = default!; // Goobstation Change
    [Dependency] private readonly CollectiveMindUpdateSystem _collectiveMind = default!; // Goobstation - Starlight collective mind port
    [Dependency] private readonly LanguageSystem _language = default!; // Einstein Engines - Language
    [Dependency] private readonly TTSSystem _tts = default!;

    private const string DefaultAnnouncementSound = "/Audio/_Europa/Announcements/announce.ogg";
    private const string CentComAnnouncementSound = "/Audio/_Europa/Announcements/centcomm.ogg";
    private const float DefaultObfuscationFactor = 0.2f;
    private readonly Color _defaultSpeakColor = Color.White; // Einstein Engines - Language

    // Floofstation - Emotes and Sign Languages Respect LOS
    private const bool SpeakRespectsLos = false;
    public const bool WhisperRespectsLos = false;
    private const bool EmoteRespectsLos = true;
    private const bool LocalOOCRespectsLos = false;

    private bool _loocEnabled = true;
    private bool _deadLoocEnabled;
    private bool _critLoocEnabled;
    private readonly bool _adminLoocEnabled = true;

    public override void Initialize()
    {
        base.Initialize();
        CacheEmotes();
        Subs.CVar(_configurationManager, CCVars.LoocEnabled, OnLoocEnabledChanged, true);
        Subs.CVar(_configurationManager, CCVars.DeadLoocEnabled, OnDeadLoocEnabledChanged, true);
        Subs.CVar(_configurationManager, CCVars.CritLoocEnabled, OnCritLoocEnabledChanged, true);

        SubscribeLocalEvent<GameRunLevelChangedEvent>(OnGameChange);
    }

    private void OnLoocEnabledChanged(bool val)
    {
        if (_loocEnabled == val)
            return;

        _loocEnabled = val;
        _chatManager.DispatchServerAnnouncement(
            Loc.GetString(val ? "chat-manager-looc-chat-enabled-message" : "chat-manager-looc-chat-disabled-message"));
    }

    private void OnDeadLoocEnabledChanged(bool val)
    {
        if (_deadLoocEnabled == val)
            return;

        _deadLoocEnabled = val;
        _chatManager.DispatchServerAnnouncement(
            Loc.GetString(val ? "chat-manager-dead-looc-chat-enabled-message" : "chat-manager-dead-looc-chat-disabled-message"));
    }

    private void OnCritLoocEnabledChanged(bool val)
    {
        if (_critLoocEnabled == val)
            return;

        _critLoocEnabled = val;
        _chatManager.DispatchServerAnnouncement(
            Loc.GetString(val ? "chat-manager-crit-looc-chat-enabled-message" : "chat-manager-crit-looc-chat-disabled-message"));
    }

    private void OnGameChange(GameRunLevelChangedEvent ev)
    {
        switch (ev.New)
        {
            case GameRunLevel.InRound:
                if (!_configurationManager.GetCVar(CCVars.OocEnableDuringRound))
                    _configurationManager.SetCVar(CCVars.OocEnabled, false);
                break;
            case GameRunLevel.PostRound:
            case GameRunLevel.PreRoundLobby:
                if (!_configurationManager.GetCVar(CCVars.OocEnableDuringRound))
                    _configurationManager.SetCVar(CCVars.OocEnabled, true);
                break;
        }
    }

    public override void TrySendInGameICMessage(
        EntityUid source,
        string message,
        InGameICChatType desiredType,
        bool hideChat,
        bool hideLog = false,
        IConsoleShell? shell = null,
        ICommonSession? player = null,
        string? nameOverride = null,
        bool checkRadioPrefix = true,
        bool ignoreActionBlocker = false,
        Color? colorOverride = null // Goobstation
        )
    {
        TrySendInGameICMessage(source,
            message,
            desiredType,
            hideChat ? ChatTransmitRange.HideChat : ChatTransmitRange.Normal,
            hideLog,
            shell,
            player,
            nameOverride,
            checkRadioPrefix,
            ignoreActionBlocker,
            colorOverride);
    }

    public void TrySendInGameICMessage(
        EntityUid source,
        string message,
        InGameICChatType desiredType,
        ChatTransmitRange range,
        bool hideLog = false,
        IConsoleShell? shell = null,
        ICommonSession? player = null,
        string? nameOverride = null,
        bool checkRadioPrefix = true,
        bool ignoreActionBlocker = false,
        Color? colorOverride = null, // Goobstation
        LanguagePrototype? languageOverride = null // Einstein Engines - Language
        )
    {
        if (HasComp<GhostComponent>(source))
        {
            TrySendInGameOOCMessage(source, message, InGameOOCChatType.Dead, range == ChatTransmitRange.HideChat, shell, player);
            return;
        }

        // Goobstation - Starlight collective mind port
        if (TryComp<CollectiveMindComponent>(source, out var collective))
            _collectiveMind.UpdateCollectiveMind(source, collective);

        if (player != null && _chatManager.HandleRateLimit(player) != RateLimitStatus.Allowed)
            return;

        if (player?.AttachedEntity is { Valid: true } entity && source != entity)
            return;

        if (!CanSendInGame(message, shell, player))
            return;

        ignoreActionBlocker = CheckIgnoreSpeechBlocker(source, ignoreActionBlocker);

        if (player != null)
        {
            _chatManager.EnsurePlayer(player.UserId).AddEntity(GetNetEntity(source));
        }

        if (desiredType == InGameICChatType.Speak && message.StartsWith(LocalPrefix))
        {
            checkRadioPrefix = false;
            message = message[1..];
        }

        var language = languageOverride ?? _language.GetLanguage(source); // Einstein Engines - Language

        var shouldCapitalize = (desiredType != InGameICChatType.Emote);
        var shouldPunctuate = _configurationManager.GetCVar(CCVars.ChatPunctuation);
        var shouldCapitalizeTheWordI = CultureInfo.CurrentCulture.Name.StartsWith("en");

        message = SanitizeInGameICMessage(source, message, out var emoteStr, shouldCapitalize, shouldPunctuate, shouldCapitalizeTheWordI);

        if (player != null && emoteStr != message && emoteStr != null)
        {
            SendEntityEmote(source, emoteStr, range, nameOverride, ignoreActionBlocker); // Einstein Engines - Language
        }

        if (string.IsNullOrEmpty(message))
            return;

        // Goobstation start
        var colorEv = new GetMessageColorOverrideEvent();
        RaiseLocalEvent(source, colorEv);
        if (colorEv.Color != null)
            colorOverride = colorEv.Color.Value;
        // Goobstation end

        if (language.SpeechOverride.ChatTypeOverride is { } chatTypeOverride)
            desiredType = chatTypeOverride;

        // Europa-Start | Is this being sent direct
        var targetEv = new CheckTargetedSpeechEvent();
        RaiseLocalEvent(source, targetEv);

        if (targetEv.Targets.Count > 0 && !targetEv.ChatTypeIgnore.Contains(desiredType))
        {
            SendEntityDirect(source, message, range, nameOverride, language, targetEv.Targets);
            return;
        }
        // Europa-End

        if (checkRadioPrefix)
        {
            if (TryProccessRadioMessage(source, message, out var modMessage, out var channel))
            {
                SendEntityWhisper(source, modMessage, range, channel, nameOverride, language, hideLog, ignoreActionBlocker, colorOverride); // Goob edit & Einstein Engines - Language
                return;
            }
        }

        // Goobstation - Starlight collective mind port
        if (desiredType == InGameICChatType.CollectiveMind &&
            TryProccessCollectiveMindMessage(source, message, out var modMessage2, out var channel2))
        {
            modMessage2 = FuckHelper.RemoveMarkupSafe(modMessage2);

            if (collective is { RespectAccents: true })
            {
                modMessage2 = TransformSpeech(source, modMessage2, language);
            }

            SendCollectiveMindChat(source, modMessage2, channel2);
            return;
        }

        switch (desiredType)
        {
            case InGameICChatType.Speak:
                SendEntitySpeak(source, message, range, nameOverride, language, hideLog, ignoreActionBlocker, colorOverride); // Goob edit & Einstein Engines - Language
                break;
            case InGameICChatType.Whisper:
                SendEntityWhisper(source, message, range, null, nameOverride, language, hideLog, ignoreActionBlocker, colorOverride); // Goob edit & Einstein Engines - Language
                break;
            case InGameICChatType.Emote:
                SendEntityEmote(source, message, range, nameOverride, hideLog: hideLog, ignoreActionBlocker: ignoreActionBlocker);
                break;
            case InGameICChatType.Telepathic:
                _telepath.SendTelepathicChat(source, message, range == ChatTransmitRange.HideChat);
                break;
        }
    }

    public void TrySendInGameOOCMessage(
        EntityUid source,
        string message,
        InGameOOCChatType type,
        bool hideChat,
        IConsoleShell? shell = null,
        ICommonSession? player = null
        )
    {
        if (!CanSendInGame(message, shell, player))
            return;

        if (player != null && _chatManager.HandleRateLimit(player) != RateLimitStatus.Allowed)
            return;

        if (player?.AttachedEntity is not { Valid: true } entity || source != entity)
            return;

        message = SanitizeInGameOOCMessage(message);

        var sendType = type;
        if ((_adminManager.IsAdmin(player) && _adminManager.HasAdminFlag(player, AdminFlags.Moderator))
            || _deadLoocEnabled
            || (!HasComp<GhostComponent>(source) && !_mobStateSystem.IsDead(source)))
        {
        }
        else
            sendType = InGameOOCChatType.Dead;

        if (!_critLoocEnabled && _mobStateSystem.IsCritical(source))
            return;

        switch (sendType)
        {
            case InGameOOCChatType.Dead:
                SendDeadChat(source, player, message, hideChat);
                break;
            case InGameOOCChatType.Looc:
                SendLooc(source, player, message, hideChat);
                break;
        }
    }

    #region Announcements

    public void DispatchGlobalAnnouncement(
        string message,
        string? sender = null,
        bool playSound = true,
        SoundSpecifier? announcementSound = null,
        Color? colorOverride = null,
        EntityUid? senderUid = null,
        bool enableTts = false,
        string onlyMessage = ""
        )
    {
        sender ??= Loc.GetString("chat-manager-sender-announcement");

        var wrappedMessage = Loc.GetString("chat-manager-sender-announcement-wrap-message", ("sender", sender), ("message", FormattedMessage.EscapeText(message)));
        _chatManager.ChatMessageToAll(ChatChannel.Radio, message, wrappedMessage, default, false, true, colorOverride);

        if (playSound)
        {
            if (sender == Loc.GetString("admin-announce-announcer-default"))
                announcementSound = new SoundPathSpecifier(CentComAnnouncementSound);
            _audio.PlayGlobal(announcementSound == null ? DefaultAnnouncementSound : _audio.ResolveSound(announcementSound),
                Filter.Broadcast(),
                true,
                AudioParams.Default.WithVolume(-2f));
        }

        if (enableTts)
        {
            if (onlyMessage.Length > 0)
                _tts.DispatchAnnouncementToAllStations(onlyMessage, senderUid);
            else
                _tts.DispatchAnnouncementToAllStations(message, senderUid);
        }

        _adminLogger.Add(LogType.Chat, LogImpact.Low, $"Global station announcement from {sender}: {message}");
    }

    public void DispatchFilteredAnnouncement(
        Filter filter,
        string message,
        EntityUid? source = null,
        string? sender = null,
        bool playSound = true,
        SoundSpecifier? announcementSound = null,
        Color? colorOverride = null,
        EntityUid? senderUid = null,
        bool enableTts = false)
    {
        sender ??= Loc.GetString("chat-manager-sender-announcement");

        var wrappedMessage = Loc.GetString("chat-manager-sender-announcement-wrap-message", ("sender", sender), ("message", FormattedMessage.EscapeText(message)));
        _chatManager.ChatMessageToManyFiltered(filter, ChatChannel.Radio, message, wrappedMessage, source ?? default, false, true, colorOverride);

        if (playSound)
        {
            _audio.PlayGlobal(announcementSound ?? new SoundPathSpecifier(DefaultAnnouncementSound), filter, true, AudioParams.Default.WithVolume(-2f));
        }

        if (enableTts && source != null)
        {
            var station = _stationSystem.GetOwningStation(source.Value);
            if (station != null)
            {
                _tts.DispatchAnnouncementToOneStation(message, station.Value, senderUid ?? source);
            }
        }

        _adminLogger.Add(LogType.Chat, LogImpact.Low, $"Station Announcement from {sender}: {message}");
    }

    public void DispatchStationAnnouncement(
        EntityUid source,
        string message,
        string? sender = null,
        bool playDefaultSound = true,
        SoundSpecifier? announcementSound = null,
        Color? colorOverride = null,
        EntityUid? senderUid = null,
        bool enableTts = false,
        string onlyMessage = "")
    {
        sender ??= Loc.GetString("chat-manager-sender-announcement");

        var wrappedMessage = Loc.GetString("chat-manager-sender-announcement-wrap-message", ("sender", sender), ("message", FormattedMessage.EscapeText(message)));
        var station = _stationSystem.GetOwningStation(source);

        if (station == null || !TryComp<StationDataComponent>(station, out var stationDataComp))
            return;

        var filter = _stationSystem.GetInStation(stationDataComp);

        _chatManager.ChatMessageToManyFiltered(filter, ChatChannel.Radio, message, wrappedMessage, source, false, true, colorOverride);

        if (playDefaultSound)
        {
            _audio.PlayGlobal(announcementSound ?? new SoundPathSpecifier(DefaultAnnouncementSound), filter, true, AudioParams.Default.WithVolume(-2f));
        }

        if (enableTts)
        {
            if (onlyMessage.Length > 0)
                _tts.DispatchAnnouncementToOneStation(onlyMessage, station.Value, senderUid ?? source);
            else
                _tts.DispatchAnnouncementToOneStation(message, station.Value, senderUid ?? source);
        }

        _adminLogger.Add(LogType.Chat, LogImpact.Low, $"Station Announcement on {station} from {sender}: {message}");
    }

    #endregion

    #region Private API

private void SendEntityDirect(
    EntityUid source,
    string originalMessage,
    ChatTransmitRange range,
    string? nameOverride,
    LanguagePrototype language,
    List<EntityUid> recipients,
    bool hideLog = false)
{
    var message = TransformSpeech(source, FuckHelper.RemoveMarkupSafe(originalMessage), language);
    if (message.Length == 0)
        return;

    var name = nameOverride ?? GetVoiceName(source);
    name = FormattedMessage.EscapeText(name);

    var wrappedMessage = Loc.GetString("chat-manager-entity-say-direct-wrap-message",
        ("entityName", name),
        ("message", FormattedMessage.EscapeText(message)));

    foreach (var (session, data) in GetRecipients(source, WhisperMuffledRange))
    {
        if (session.AttachedEntity is not { Valid: true })
            continue;
        var listener = session.AttachedEntity.Value;

        if (MessageRangeCheck(session, data, range) != MessageRangeCheckResult.Full ||
            !recipients.Contains(listener) && !HasComp<GhostComponent>(listener))
            continue;

        _chatManager.ChatMessageToOne(ChatChannel.CollectiveMind, message, wrappedMessage, source, false, session.Channel);
    }

    if (hideLog)
        return;

    if (name != Name(source))
    {
        if (originalMessage == message)
        {
            _adminLogger.Add(LogType.Chat, LogImpact.Low, $"Direct messaged from {ToPrettyString(source):user} as {name}: {originalMessage}.");
        }
        else
        {
            _adminLogger.Add(LogType.Chat, LogImpact.Low, $"Direct messaged from {ToPrettyString(source):user} as {name}, original: {originalMessage}, transformed: {message}.");
        }
    }
    else
    {
        if (originalMessage == message)
        {
            _adminLogger.Add(LogType.Chat, LogImpact.Low, $"Direct messaged from {ToPrettyString(source):user}: {originalMessage}.");
        }
        else
        {
            _adminLogger.Add(LogType.Chat, LogImpact.Low, $"Direct messaged from {ToPrettyString(source):user}, original: {originalMessage}, transformed: {message}.");
        }
    }
}

private void SendEntityEmote(
    EntityUid source,
    string action,
    ChatTransmitRange range,
    string? nameOverride,
    bool hideLog = false,
    bool checkEmote = true,
    bool ignoreActionBlocker = false,
    NetUserId? author = null
    )
{
    if (!_actionBlocker.CanEmote(source) && !ignoreActionBlocker)
        return;

    var ent = Identity.Entity(source, EntityManager);
    var name = FormattedMessage.EscapeText(nameOverride ?? Name(ent));

    var wrappedMessage = Loc.GetString("chat-manager-entity-me-wrap-message",
        ("entityName", name),
        ("entity", ent),
        ("message", FuckHelper.RemoveMarkupSafe(action)));

    if (checkEmote && !TryEmoteChatInput(source, action))
        return;

    SendInVoiceRange(ChatChannel.Emotes, action, wrappedMessage, "", "", source, range, author, checkLos: EmoteRespectsLos);

    if (hideLog)
        return;

    if (name != Name(source))
    {
        _adminLogger.Add(LogType.Chat, LogImpact.Low, $"Emote from {ToPrettyString(source):user} as {name}: {action}");
    }
    else
    {
        _adminLogger.Add(LogType.Chat, LogImpact.Low, $"Emote from {ToPrettyString(source):user}: {action}");
    }
}

private void SendLooc(EntityUid source, ICommonSession player, string message, bool hideChat)
{
    var name = FormattedMessage.EscapeText(Identity.Name(source, EntityManager));

    if (_adminManager.IsAdmin(player))
    {
        if (!_adminLoocEnabled)
            return;
    }
    else if (!_loocEnabled)
        return;

    if (!_critLoocEnabled && _mobStateSystem.IsCritical(source))
        return;

    var wrappedMessage = Loc.GetString("chat-manager-entity-looc-wrap-message",
        ("entityName", name),
        ("message", FormattedMessage.EscapeText(message)));

    SendInVoiceRange(ChatChannel.LOOC,
        message,
        wrappedMessage,
        "",
        "",
        source,
        hideChat ? ChatTransmitRange.HideChat : ChatTransmitRange.Normal,
        player.UserId,
        languageOverride: SharedLanguageSystem.Universal,
        checkLos: LocalOOCRespectsLos);

    _adminLogger.Add(LogType.Chat, LogImpact.Low, $"LOOC from {player:Player}: {message}");
}

private void SendDeadChat(EntityUid source, ICommonSession player, string message, bool hideChat)
{
    var clients = GetDeadChatClients();
    var playerName = Name(source);
    string wrappedMessage;

    var speech = GetSpeechVerb(source, message);

    if (_adminManager.IsAdmin(player))
    {
        wrappedMessage = Loc.GetString("chat-manager-send-admin-dead-chat-wrap-message",
            ("verb", Loc.GetString(_random.Pick(speech.SpeechVerbStrings))),
            ("adminChannelName", Loc.GetString("chat-manager-admin-channel-name")),
            ("userName", player.Channel.UserName),
            ("message", FormattedMessage.EscapeText(message)));
        _adminLogger.Add(LogType.Chat, LogImpact.Low, $"Admin dead chat from {player:Player}: {message}");
    }
    else
    {
        wrappedMessage = Loc.GetString("chat-manager-send-dead-chat-wrap-message",
            ("verb", Loc.GetString(_random.Pick(speech.SpeechVerbStrings))),
            ("deadChannelName", Loc.GetString("chat-manager-dead-channel-name")),
            ("playerName", (playerName)),
            ("message", FormattedMessage.EscapeText(message)));
        _adminLogger.Add(LogType.Chat, LogImpact.Low, $"Dead chat from {player:Player}: {message}");
    }

    _chatManager.ChatMessageToMany(ChatChannel.Dead, message, wrappedMessage, source, hideChat, true, clients.ToList(), author: player.UserId);
}

private string GetVoiceName(EntityUid source)
{
    var nameEv = new TransformSpeakerNameEvent(source, Name(source));
    RaiseLocalEvent(source, nameEv);
    return nameEv.VoiceName;
}

    private void SendCollectiveMindChat(EntityUid source, string message, CollectiveMindPrototype? collectiveMind)
    {
        if (_mobStateSystem.IsDead(source) || collectiveMind == null || message == "" ||
            !TryComp<CollectiveMindComponent>(source, out var sourseCollectiveMindComp) || !sourseCollectiveMindComp.Minds.ContainsKey(collectiveMind.ID))
            return;

        var clients = Filter.Empty();
        var clientsSeeNames = Filter.Empty();
        var receivers = new HashSet<EntityUid>();
        var mindQuery = EntityQueryEnumerator<CollectiveMindComponent, ActorComponent>();

        while (mindQuery.MoveNext(out var uid, out var collectMindComp, out var actorComp))
        {
            if (_mobStateSystem.IsDead(uid))
                continue;

            if (collectMindComp.Minds.ContainsKey(collectiveMind.ID) || collectMindComp.HearAll)
            {
                if (collectMindComp.SeeAllNames)
                    clientsSeeNames.AddPlayer(actorComp.PlayerSession);
                else
                    clients.AddPlayer(actorComp.PlayerSession);
                receivers.Add(uid);
            }
        }

        var number = $"{sourseCollectiveMindComp.Minds[collectiveMind.ID]}";
        var admins = _adminManager.ActiveAdmins.Select(p => p.Channel);

        var messageWrap = Loc.GetString("collective-mind-chat-wrap-message",
            ("message", message),
            ("channel", collectiveMind.LocalizedName),
            ("number", number));
        var namedMessageWrap = Loc.GetString("collective-mind-chat-wrap-message-named",
            ("source", source),
            ("message", message),
            ("channel", collectiveMind.LocalizedName));
        var adminMessageWrap = Loc.GetString("collective-mind-chat-wrap-message-admin",
            ("source", source),
            ("message", message),
            ("channel", collectiveMind.LocalizedName),
            ("number", number));

        _adminLogger.Add(LogType.Chat, LogImpact.Low, $"CollectiveMind chat from {ToPrettyString(source):Player}: {message}");

        _chatManager.ChatMessageToManyFiltered(clients,
            ChatChannel.CollectiveMind,
            message,
            collectiveMind.ShowNames ? namedMessageWrap : messageWrap,
            source,
            false,
            true,
            collectiveMind.Color);

        _chatManager.ChatMessageToManyFiltered(clientsSeeNames,
            ChatChannel.CollectiveMind,
            message,
            namedMessageWrap,
            source,
            false,
            true,
            collectiveMind.Color);

        _chatManager.ChatMessageToMany(ChatChannel.CollectiveMind,
            message,
            adminMessageWrap,
            source,
            false,
            true,
            admins,
            collectiveMind.Color);
        RaiseLocalEvent(new CollectiveMindSpokeEvent(source, message, receivers, collectiveMind.ID));
    }

    private void SendEntitySpeak(
        EntityUid source,
        string originalMessage,
        ChatTransmitRange range,
        string? nameOverride,
        LanguagePrototype language, // Einstein Engines - Language
        bool hideLog = false,
        bool ignoreActionBlocker = false,
        Color? colorOverride = null // Goobstation
        )
    {
        if (!_actionBlocker.CanSpeak(source) && !ignoreActionBlocker)
            return;

        var message = FormattedMessage.EscapeText(originalMessage);
        message = FuckHelper.RemoveMarkupSafe(message);
        message = TransformSpeech(source, message, language);

        if (message.Length == 0)
            return;

        GetSpeechVerb(source, message);

        string name;
        if (nameOverride != null)
        {
            name = nameOverride;
        }
        else
        {
            var nameEv = new TransformSpeakerNameEvent(source, Name(source));
            RaiseLocalEvent(source, nameEv);
            name = nameEv.VoiceName;
        }

        name = FormattedMessage.EscapeText(name);

        var typeLos = SpeakRespectsLos || language.SpeechOverride.RequireLOS;
        if (language.SpeechOverride is { RequireSpeech: false, RequireLOS: true })
        {
            var ent = Identity.Entity(source, EntityManager);
            name = FormattedMessage.EscapeText(nameOverride ?? Name(ent));
        }

        // The chat message wrapped in a "x says y" string.
        var wrappedMessage = WrapPublicMessage(source, name, message, language: language, colorOverride);
        // The chat message obfuscated via language obfuscation.
        var obfuscated = SanitizeInGameICMessage(source, _language.ObfuscateSpeech(message, language), out var emoteStr, true, _configurationManager.GetCVar(CCVars.ChatPunctuation),
        (!CultureInfo.CurrentCulture.IsNeutralCulture && CultureInfo.CurrentCulture.Parent.Name == "en")
        || (CultureInfo.CurrentCulture.IsNeutralCulture && CultureInfo.CurrentCulture.Name == "en"));
        // The language-obfuscated message wrapped in a "x says y" string.
        var wrappedObfuscated = WrapPublicMessage(source, name, obfuscated, language: language, colorOverride);
        // Einstein Engines - Language end

        SendInVoiceRange(ChatChannel.Local,
            message,
            wrappedMessage,
            obfuscated,
            wrappedObfuscated,
            source,
            range,
            languageOverride: language,
            checkLos: typeLos);

        var ev = new EntitySpokeEvent(source, message, null, false, language);
        RaiseLocalEvent(source, ev, true);

        if (!HasComp<ActorComponent>(source) || hideLog)
            return;

        if (name != Name(source))
        {
            if (name != Name(source))
                _adminLogger.Add(LogType.Chat, LogImpact.Low, $"Say from {ToPrettyString(source):user} as {name}: {originalMessage}.");
            else
                _adminLogger.Add(LogType.Chat, LogImpact.Low, $"Say from {ToPrettyString(source):user}: {originalMessage}.");
        }
        else
        {
            if (name != Name(source))
            {
                _adminLogger.Add(LogType.Chat,
                    LogImpact.Low,
                    $"Say from {ToPrettyString(source):user} as {name}, original: {originalMessage}, transformed: {message}.");
            }
            else
            {
                _adminLogger.Add(LogType.Chat,
                    LogImpact.Low,
                    $"Say from {ToPrettyString(source):user}, original: {originalMessage}, transformed: {message}.");
            }
        }
    }

    private void SendEntityWhisper(
        EntityUid source,
        string originalMessage,
        ChatTransmitRange range,
        RadioChannelPrototype? channel,
        string? nameOverride,
        LanguagePrototype language, // Einstein Engines - Language
        bool hideLog = false,
        bool ignoreActionBlocker = false,
        Color? colorOverride = null // Goobstation
        )
    {
        if (!_actionBlocker.CanSpeak(source) && !ignoreActionBlocker)
            return;

        var message = TransformSpeech(source, FormattedMessage.RemoveMarkupOrThrow(originalMessage), language); // Einstein Engines - Language
        if (message.Length == 0)
            return;

        // get the entity's name by visual identity (if no override provided).
        string nameIdentity = FormattedMessage.EscapeText(nameOverride ?? Identity.Name(source, EntityManager));
        // get the entity's name by voice (if no override provided).
        string name;
        if (nameOverride != null)
        {
            name = nameOverride;
        }
        else
        {
            var nameEv = new TransformSpeakerNameEvent(source, Name(source));
            RaiseLocalEvent(source, nameEv);
            name = nameEv.VoiceName;
        }
        name = FormattedMessage.EscapeText(name);

        if (!language.SpeechOverride.RequireSpeech && language.SpeechOverride.RequireLOS)
        {
            // Since this is basically an emote, make it act like an emote for identity.
            var ent = Identity.Entity(source, EntityManager);
            name = FormattedMessage.EscapeText(nameOverride ?? Name(ent));
        }

        var languageObfuscatedMessage = SanitizeInGameICMessage(source, _language.ObfuscateSpeech(message, language), out var emoteStr, true, _configurationManager.GetCVar(CCVars.ChatPunctuation),
        (!CultureInfo.CurrentCulture.IsNeutralCulture && CultureInfo.CurrentCulture.Parent.Name == "en")
        || (CultureInfo.CurrentCulture.IsNeutralCulture && CultureInfo.CurrentCulture.Name == "en")); // Einstein Engines - Language

        foreach (var (session, data) in GetRecipients(source, WhisperMuffledRange))
        {
            if (session.AttachedEntity is not { Valid: true } listener)
                continue;

            if (MessageRangeCheck(session, data, range) != MessageRangeCheckResult.Full)
                continue; // Won't get logged to chat, and ghosts are too far away to see the pop-up, so we just won't send it to them.

            // Goob edit start
            if (TryComp<DeafComponent>(listener, out var modifier) && language.SpeechOverride.RequireSpeech)
                continue; // blocks anyone with the deaf component from hearing.
            // Goob edit end

            // Einstein Engines - Language begin
            var canUnderstandLanguage = _language.CanUnderstand(listener, language.ID);
            // How the entity perceives the message depends on whether it can understand its language
            var perceivedMessage = canUnderstandLanguage ? message : languageObfuscatedMessage;

            // Result is the intermediate message derived from the perceived one via obfuscation
            // Wrapped message is the result wrapped in an "x says y" string
            // Floof: handle languages that require LOS
            string result, wrappedMessage;
            if (!language.SpeechOverride.RequireLOS && data.Range <= WhisperClearRange
                || _examineSystem.InRangeUnOccluded(source, listener, WhisperClearRange)
                || data.Observer)
            {
                // Scenario 1: the listener can clearly understand the message
                result = perceivedMessage;
                wrappedMessage = WrapWhisperMessage(source, "chat-manager-entity-whisper-wrap-message", name, result, language, colorOverride);
            }
            else if (_examineSystem.InRangeUnOccluded(source, listener, WhisperMuffledRange)) // UNEDIT FROM Einstein Engines - Language // They are out of date, this has been reverted to current ChatSystem
            {
                // Scenario 2: if the listener is too far, they only hear fragments of the message
                result = ObfuscateMessageReadability(perceivedMessage);
                wrappedMessage = WrapWhisperMessage(source, "chat-manager-entity-whisper-wrap-message", nameIdentity, result, language, colorOverride);
            }
            else
            {
                if (language.SpeechOverride.RequireLOS) // Floof - If there is no LOS, listener sees nothing.
                    continue;

                // Scenario 3: If listener is too far and has no line of sight, they can't identify the whisperer's identity
                result = ObfuscateMessageReadability(perceivedMessage);
                wrappedMessage = WrapWhisperMessage(source, "chat-manager-entity-whisper-unknown-wrap-message", string.Empty, result, language, colorOverride);
            }

            _chatManager.ChatMessageToOne(ChatChannel.Whisper, result, wrappedMessage, source, false, session.Channel);
        }

        var replayWrap = WrapWhisperMessage(source, "chat-manager-entity-whisper-wrap-message", name, message, language, colorOverride);
        _replay.RecordServerMessage(new ChatMessage(ChatChannel.Whisper, message, replayWrap, GetNetEntity(source), null, MessageRangeHideChatForReplay(range)));
        // Einstein Engines - Languages end

        var ev = new EntitySpokeEvent(source, message, channel, true, language); // Einstein Engines - Languages
        RaiseLocalEvent(source, ev, true);
        if (!hideLog)
        {
            if (originalMessage == message)
            {
                _adminLogger.Add(LogType.Chat, $"Say from {ToPrettyString(source):user} as {name}: {originalMessage}.");
            }
            else
            {
                _adminLogger.Add(LogType.Chat, $"Say from {ToPrettyString(source):user} as {name}, original: {originalMessage}, transformed: {message}.");
            }
        }
        else
        {
            if (originalMessage == message)
            {
                _adminLogger.Add(LogType.Chat, $"Say from {ToPrettyString(source):user}: {originalMessage}.");
            }
            else
            {
                _adminLogger.Add(LogType.Chat, $"Say from {ToPrettyString(source):user}, original: {originalMessage}, transformed: {message}.");
            }
        }
    }

    #endregion

    #region Utility

    private enum MessageRangeCheckResult
    {
        Disallowed,
        HideChat,
        Full
    }

    private bool MessageRangeHideChatForReplay(ChatTransmitRange range)
    {
        return range == ChatTransmitRange.HideChat;
    }

    private MessageRangeCheckResult MessageRangeCheck(ICommonSession session, ICChatRecipientData data, ChatTransmitRange range)
    {
        var initialResult = range switch
        {
            ChatTransmitRange.Normal => MessageRangeCheckResult.Full,
            ChatTransmitRange.GhostRangeLimit => (data is { Observer: true, Range: < 0 } && !_adminManager.IsAdmin(session))
                ? MessageRangeCheckResult.HideChat
                : MessageRangeCheckResult.Full,
            ChatTransmitRange.HideChat => MessageRangeCheckResult.HideChat,
            ChatTransmitRange.NoGhosts => (data.Observer && !_adminManager.IsAdmin(session))
                ? MessageRangeCheckResult.Disallowed
                : MessageRangeCheckResult.Full,
            _ => MessageRangeCheckResult.Full
        };

        var insistHideChat = data.HideChatOverride ?? false;
        var insistNoHideChat = !(data.HideChatOverride ?? true);

        if (insistHideChat && initialResult == MessageRangeCheckResult.Full)
            return MessageRangeCheckResult.HideChat;
        if (insistNoHideChat && initialResult == MessageRangeCheckResult.HideChat)
            return MessageRangeCheckResult.Full;

        return initialResult;
    }

    private void SendInVoiceRange(
        ChatChannel channel,
        string message,
        string wrappedMessage,
        string obfuscated,
        string obfuscatedWrappedMessage,
        EntityUid source,
        ChatTransmitRange range,
        NetUserId? author = null,
        LanguagePrototype? languageOverride = null,
        bool checkLos = false
        )
    {
        var language = languageOverride ?? _language.GetLanguage(source);

        foreach (var (session, data) in GetRecipients(source, VoiceRange))
        {
            var entRange = MessageRangeCheck(session, data, range);
            if (entRange == MessageRangeCheckResult.Disallowed)
                continue;
            var entHideChat = entRange == MessageRangeCheckResult.HideChat;

            if (session.AttachedEntity is not { Valid: true })
                continue;
            if (checkLos && data is { Observer: false, InLos: false })
                continue;

            var listener = session.AttachedEntity.Value;

            var ev = new ChatMessageOverrideInVoiceRange();
            RaiseLocalEvent(listener, ref ev);
            if (channel == ChatChannel.Local && language.SpeechOverride.RequireSpeech && ev.Cancelled)
                continue;

            if (channel == ChatChannel.LOOC || channel == ChatChannel.Emotes || _language.CanUnderstand(listener, language.ID))
                _chatManager.ChatMessageToOne(channel, message, wrappedMessage, source, entHideChat, session.Channel, author: author);
            else
                _chatManager.ChatMessageToOne(channel, obfuscated, obfuscatedWrappedMessage, source, entHideChat, session.Channel, author: author);
        }

        _replay.RecordServerMessage(new ChatMessage(channel, message, wrappedMessage, GetNetEntity(source), null, MessageRangeHideChatForReplay(range)));
    }

    private bool CanSendInGame(string message, IConsoleShell? shell = null, ICommonSession? player = null)
    {
        if (player == null)
            return true;

        var mindContainerComponent = player.ContentData()?.Mind;

        if (mindContainerComponent == null)
        {
            shell?.WriteError("You don't have a mind!");
            return false;
        }

        if (player.AttachedEntity is not { Valid: true } _)
        {
            shell?.WriteError("You don't have an entity!");
            return false;
        }

        return !_chatManager.MessageCharacterLimit(player, message);
    }

    // ReSharper disable once InconsistentNaming
    private string SanitizeInGameICMessage(EntityUid source, string message, out string? emoteStr, bool capitalize = true, bool punctuate = false, bool capitalizeTheWordI = true)
    {
        var newMessage = SanitizeMessageReplaceWords(message.Trim());

        newMessage = FuckHelper.SanitizeSimpleMessageForChat(newMessage);

        GetRadioKeycodePrefix(source, newMessage, out newMessage, out var prefix);

        // Sanitize it first as it might change the word order
        _sanitizer.TrySanitizeEmoteShorthands(newMessage, source, out newMessage, out emoteStr);

        if (capitalize)
            newMessage = SanitizeMessageCapital(newMessage);
        if (capitalizeTheWordI)
            newMessage = SanitizeMessageCapitalizeTheWordI(newMessage);
        if (punctuate)
            newMessage = SanitizeMessagePeriod(newMessage);

        return prefix + newMessage;
    }

    private string SanitizeInGameOOCMessage(string message)
    {
        var newMessage = message.Trim();
        newMessage = FuckHelper.SanitizeSimpleMessageForChat(newMessage);

        return newMessage;
    }

    private string TransformSpeech(EntityUid sender, string message, LanguagePrototype language) // Einstein Engines - Language
    {
        if (!language.SpeechOverride.RequireSpeech) // Einstein Engines - Language
            return message; // Do not apply speech accents if there's no speech involved.

        var ev = new TransformSpeechEvent(sender, message);
        RaiseLocalEvent(ev);

        return ev.Message;
    }

    private bool CheckIgnoreSpeechBlocker(EntityUid sender, bool ignoreBlocker)
    {
        if (ignoreBlocker)
            return ignoreBlocker;

        var ev = new CheckIgnoreSpeechBlockerEvent(sender, ignoreBlocker);
        RaiseLocalEvent(sender, ev, true);

        return ev.IgnoreBlocker;
    }

    private IEnumerable<INetChannel> GetDeadChatClients()
    {
        if (_ghostVisibility.GhostsVisible()) // Goobstation
            return Filter.Broadcast().Recipients.Select(p => p.Channel);

        return Filter.Empty()
            .AddWhereAttachedEntity(HasComp<GhostComponent>)
            .AddWhereAttachedEntity(_scrying.IsScryingOrbEquipped) // Goobstation
            .Recipients
            .Union(_adminManager.ActiveAdmins)
            .Select(p => p.Channel);
    }

    private string SanitizeMessagePeriod(string message)
    {
        if (string.IsNullOrEmpty(message))
            return message;
        // Adds a period if the last character is a letter.
        if (char.IsLetter(message[^1]))
            message += ".";
        return message;
    }

    private static readonly ProtoId<ReplacementAccentPrototype> ChatSanitizeAccent = "chatsanitize";

    private string SanitizeMessageReplaceWords(string message)
    {
        if (string.IsNullOrEmpty(message))
            return message;

        var msg = message;

        msg = _wordreplacement.ApplyReplacements(msg, ChatSanitizeAccent);

        return msg;
    }

    // Einstein Engines - Language begin
    /// <summary>
    ///     Wraps a message sent by the specified entity into an "x says y" string.
    /// </summary>
    public string WrapPublicMessage(EntityUid source, string name, string message, LanguagePrototype? language = null, Color? colorOverride = null)
    {
        var wrapId = GetSpeechVerb(source, message).Bold ? "chat-manager-entity-say-bold-wrap-message" : "chat-manager-entity-say-wrap-message";
        return WrapMessage(wrapId, InGameICChatType.Speak, source, name, message, language, colorOverride);
    }

    /// <summary>
    ///     Wraps a message whispered by the specified entity into an "x whispers y" string.
    /// </summary>
    public string WrapWhisperMessage(EntityUid source, LocId defaultWrap, string entityName, string message, LanguagePrototype? language = null, Color? colorOverride = null)
    {
        return WrapMessage(defaultWrap, InGameICChatType.Whisper, source, entityName, message, language, colorOverride);
    }

    /// <summary>
    ///     Wraps a message sent by the specified entity into the specified wrap string.
    /// </summary>
    public string WrapMessage(LocId wrapId, InGameICChatType chatType, EntityUid source, string entityName, string message, LanguagePrototype? language, Color? colorOverride)
    {
        var speech = GetSpeechVerb(source, message);
        language ??= _language.GetLanguage(source);

        // Goobstation - Bolded Language Overrides begin
        if (language.SpeechOverride.BoldFontId != null && speech.Bold)
            wrapId = "chat-manager-entity-say-bolded-language-wrap-message";
        // Goobstation end

        if (language.SpeechOverride.MessageWrapOverrides.TryGetValue(chatType, out var wrapOverride))
            wrapId = wrapOverride;

        var verbId = language.SpeechOverride.SpeechVerbOverrides is { } verbsOverride
            ? _random.Pick(verbsOverride).ToString()
            : _random.Pick(speech.SpeechVerbStrings);

        var color = _defaultSpeakColor;
        colorOverride ??= language.SpeechOverride.Color;
        if (colorOverride != null)
            color = Color.InterpolateBetween(color, colorOverride.Value, colorOverride.Value.A);
        var languageDisplay = language.IsVisibleLanguage
            ? Loc.GetString("chat-manager-language-prefix", ("language", language.ChatName))
            : "";

        // goob start - loudspeakers

        int? loudSpeakFont = null;

        var getLoudspeakerEv = new GetLoudspeakerEvent();
        RaiseLocalEvent(source, ref getLoudspeakerEv);

        if (getLoudspeakerEv.Loudspeakers != null)
            foreach (var loudspeaker in getLoudspeakerEv.Loudspeakers)
            {
                var loudSpeakerEv = new GetLoudspeakerDataEvent();
                RaiseLocalEvent(loudspeaker, ref loudSpeakerEv);

                if (loudSpeakerEv.IsActive && loudSpeakerEv.AffectChat)
                {
                    loudSpeakFont = loudSpeakerEv.FontSize;
                    break;
                }
            }

        // goob end

        return Loc.GetString(wrapId,
            ("color", color),
            ("entityName", entityName),
            ("verb", Loc.GetString(verbId)),
            ("fontType", language.SpeechOverride.FontId ?? speech.FontId),
            ("fontSize", loudSpeakFont ?? language.SpeechOverride.FontSize ?? speech.FontSize), // goob edit - "loudSpeakFont"
            ("boldFontType", language.SpeechOverride.BoldFontId ?? language.SpeechOverride.FontId ?? speech.FontId), // Goob Edit - Custom Bold Fonts
            ("message", message),
            ("language", languageDisplay));
    }
    // Einstein Engines - Language end

    /// <summary>
    ///     Returns list of players and ranges for all players withing some range. Also returns observers with a range of -1.
    /// </summary>
    private Dictionary<ICommonSession, ICChatRecipientData> GetRecipients(EntityUid source, float voiceGetRange)
    {
        // TODO proper speech occlusion

        var recipients = new Dictionary<ICommonSession, ICChatRecipientData>();
        var ghostHearing = GetEntityQuery<GhostHearingComponent>();
        var xforms = GetEntityQuery<TransformComponent>();

        var transformSource = xforms.GetComponent(source);
        var sourceMapId = transformSource.MapID;
        var sourceCoords = transformSource.Coordinates;

        foreach (var player in _playerManager.Sessions)
        {
            if (player.AttachedEntity is not { Valid: true } playerEntity)
                continue;

            var transformEntity = xforms.GetComponent(playerEntity);

            if (transformEntity.MapID != sourceMapId)
                continue;

            var observer = ghostHearing.HasComponent(playerEntity);

            // Floofstation - Check Line-Of-Sight begin
            sourceCoords.TryDistance(EntityManager, transformEntity.Coordinates, out var distance);

            // InRangeUnOccluded does this check, but it also checks for occlusion
            // which doesn't really work for modes that are supposed to go through walls, like Speak
            var inRange = distance <= voiceGetRange;

            var isVisible = observer || (inRange && _examineSystem.InRangeUnOccluded(source, playerEntity, voiceGetRange));
            // Floofstation - end

            // even if they are a ghost hearer, in some situations we still need the range
            if (inRange) // Floofstation - Check Line-Of-Sight
            {
                recipients.Add(player, new ICChatRecipientData(distance, observer, InLos: isVisible));
                continue;
            }

            if (observer)
                recipients.Add(player, new ICChatRecipientData(-1, true, InLos: isVisible));
        }

        RaiseLocalEvent(new ExpandICChatRecipientsEvent(source, voiceGetRange, recipients));
        return recipients;
    }

    public readonly record struct ICChatRecipientData(float Range, bool Observer, bool? HideChatOverride = null, bool InLos = true) // Floofstation - Check Line-Of-Sight
    {
    }

    public string ObfuscateMessageReadability(string message, float chance = DefaultObfuscationFactor) // Einstein Engines - Language
    {
        var modifiedMessage = new StringBuilder(message);

        for (var i = 0; i < message.Length; i++)
        {
            if (char.IsWhiteSpace((modifiedMessage[i])))
            {
                continue;
            }

            if (_random.Prob(1 - chance))
            {
                modifiedMessage[i] = '~';
            }
        }

        return modifiedMessage.ToString();
    }

    public string BuildGibberishString(IReadOnlyList<char> charOptions, int length)
    {
        var sb = new StringBuilder();
        for (var i = 0; i < length; i++)
        {
            sb.Append(_random.Pick(charOptions));
        }
        return sb.ToString();
    }

    #endregion
}

/// <summary>
///     This event is raised before chat messages are sent out to clients. This enables some systems to send the chat
///     messages to otherwise out-of view entities (e.g. for multiple viewports from cameras).
/// </summary>
public record ExpandICChatRecipientsEvent(EntityUid Source, float VoiceRange, Dictionary<ICommonSession, ChatSystem.ICChatRecipientData> Recipients)
{
}

/// <summary>
///     Raised broadcast in order to transform speech. transmit
/// </summary>
public sealed class TransformSpeechEvent : EntityEventArgs
{
    public EntityUid Sender;
    public string Message;

    public TransformSpeechEvent(EntityUid sender, string message)
    {
        Sender = sender;
        Message = message;
    }
}

public sealed class CheckIgnoreSpeechBlockerEvent : EntityEventArgs
{
    public EntityUid Sender;
    public bool IgnoreBlocker;

    public CheckIgnoreSpeechBlockerEvent(EntityUid sender, bool ignoreBlocker)
    {
        Sender = sender;
        IgnoreBlocker = ignoreBlocker;
    }
}

public sealed class CheckTargetedSpeechEvent : EntityEventArgs // Europa
{
    public List<InGameICChatType> ChatTypeIgnore = new();
    public List<EntityUid> Targets = new();
}

/// <summary>
///     Raised on an entity when it speaks, either through 'say' or 'whisper'.
/// </summary>
public sealed class EntitySpokeEvent : EntityEventArgs
{
    public readonly EntityUid Source;
    public readonly string Message;
    public readonly bool IsWhisper;
    public readonly LanguagePrototype Language;

    /// <summary>
    ///     If the entity was trying to speak into a radio, this was the channel they were trying to access. If a radio
    ///     message gets sent on this channel, this should be set to null to prevent duplicate messages.
    /// </summary>
    public RadioChannelPrototype? Channel;

    public EntitySpokeEvent(EntityUid source, string message, RadioChannelPrototype? channel, bool isWhisper, LanguagePrototype language) // Einstein Engines - Language
    {
        Source = source;
        Message = message;
        Channel = channel;
        IsWhisper = isWhisper;
        Language = language;
    }
}

// The three chat type enums (InGameICChatType, InGameOOCChatType, and ChatTransmitRange) have been moved to Shared.
